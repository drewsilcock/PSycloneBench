package shallow;

import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Count;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Count.Counter;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.CounterChain;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Stream.OffsetExpr;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;

class shallowKernel extends Kernel {

	private static final DFEType type = dfeFloat(11, 53);

	protected shallowKernel(KernelParameters parameters) {
		super(parameters);

		int m = 64, n = 64, itmax = 10;

        OffsetExpr plength = stream.makeOffsetAutoLoop("plength");

		// Carry over variables from the previous loop iteration
		DFEVar carriedp = type.newInstance(this);
		DFEVar carriedu = type.newInstance(this);
		DFEVar carriedv = type.newInstance(this);
		DFEVar carriedpold = type.newInstance(this);
		DFEVar carrieduold = type.newInstance(this);
		DFEVar carriedvold = type.newInstance(this);

		CounterChain tickchain = control.count.makeCounterChain();
		CounterChain arraychain = control.count.makeCounterChain();

		DFEVar looplength = plength.getDFEVar(getKernel(), dfeUInt(32));

		// tick is the global tick count since the start of the simulation
		DFEVar tick = tickchain.addCounter(((itmax - 1) * looplength) + (m * n), 1);
		// iter is the current iteration (0 .. itmax - 1)
		DFEVar iter = arraychain.addCounter(itmax, 1);
		// itertick is the tick within the current iteration (0 .. looplength - 1)
		DFEVar itertick = arraychain.addCounter(looplength, 1);

		debug.simPrintf(tick.eq(0), "Loop length: %d\n", looplength);

		// i & j are set up to represent the position within the arrays for the current
		// iteration. They don't count when waiting for the loop carried values
		Count.Params jparams =  control.count.makeParams(32).withMax(n)
		    .withInc(1).withEnable(itertick < m * n);
		Counter jcounter = control.count.makeCounter(jparams);
		DFEVar j = jcounter.getCount();

		Count.Params iparams = control.count.makeParams(32).withMax(m).withInc(1).withEnable(jcounter.getWrap());
		Counter icounter = control.count.makeCounter(iparams);
		DFEVar i = icounter.getCount();

		// We only need to read the inputs from the CPU on the first iteration
		DFEVar pcpu = io.input("p", type, tick < m * n);
		DFEVar ucpu = io.input("u", type, tick < m * n);
		DFEVar vcpu = io.input("v", type, tick < m * n);
		DFEVar poldcpu = io.input("pold", type, tick < m * n);
		DFEVar uoldcpu = io.input("uold", type, tick < m * n);
		DFEVar voldcpu = io.input("vold", type, tick < m * n);
		DFEVar fsdx = io.scalarInput("fsdx", type);
		DFEVar fsdy = io.scalarInput("fsdy", type);
		DFEVar tdt = io.scalarInput("tdt", type);
		DFEVar dx = io.scalarInput("dx", type);
		DFEVar dy = io.scalarInput("dy", type);
		DFEVar alpha = io.scalarInput("alpha", type);

		DFEVar p = iter.eq(0) ? pcpu : carriedp;
		DFEVar u = iter.eq(0) ? ucpu : carriedu;
		DFEVar v = iter.eq(0) ? vcpu : carriedv;
		DFEVar pold = iter.eq(0) ? poldcpu : carriedpold;
		DFEVar uold = iter.eq(0) ? uoldcpu : carrieduold;
		DFEVar vold = iter.eq(0) ? voldcpu : carriedvold;

		DFEVar cu = 0.5 * (p + stream.offset(p, -n)) * u;
		DFEVar cv = 0.5 * (p + stream.offset(p, -1)) * v;
		DFEVar z = (fsdx * (v - stream.offset(v, -n)) - fsdy * (u - stream.offset(u, -1))) /
		           (stream.offset(p, -n - 1) + stream.offset(p, -1) + p + stream.offset(p, -n));
		DFEVar h =  p + 0.25 * (stream.offset(u, n) * stream.offset(u, n) + u *
                         u + stream.offset(v, 1) * stream.offset(v, 1) + v * v);

		DFEVar h_b = itertick.eq(n * m - 1) ? stream.offset(h, -n * m + 1) :
			         j.eq(n - 1) ?  stream.offset(h, -n + 1)  :
			         i.eq(m - 1) ? stream.offset(h, -n * (m - 1)) :
			         h;
	    DFEVar cu_b = i.eq(0) ? stream.offset(cu, n * (m -1)) :
	    	          cu;
	    DFEVar cv_b = j.eq(0) ? stream.offset(cv, n -1) :
	    	          i.eq(0) ? stream.offset(cv, n * (m -1)) :
	    			  cv;
	    DFEVar z_b = itertick.eq(0) ? stream.offset(z, n * m - 1) :
	    	         i.eq(0) ? stream.offset(z, n * (m -1)) :
	    	         j.eq(0) ? stream.offset(z, n -1) :
	    	         z;

	    // tdt doubles after the first iteration
	    DFEVar tdtval = tick >= m * n ? tdt + tdt : tdt;
	    DFEVar tdts8 = tdtval / 8.0;
	    DFEVar tdtsdx = tdtval / dx;
	    DFEVar tdtsdy = tdtval / dy;

	    DFEVar unew = uold + tdts8 * (stream.offset(z_b, 1) + z_b) *
	                  (stream.offset(cv_b, 1) + stream.offset(cv_b, -n + 1) + stream.offset(cv_b, -n) + cv_b) -
	                  tdtsdx * (h_b - stream.offset(h_b, -n));
	    DFEVar vnew = vold - tdts8 * (stream.offset(z_b, n) + z_b) *
	                  (stream.offset(cu_b, n) + cu_b + stream.offset(cu_b, -1) + stream.offset(cu_b, n -1)) -
	                  tdtsdy * (h_b - stream.offset(h_b, -1));
	    DFEVar pnew = pold - tdtsdx * (stream.offset(cu_b, n) - cu_b) -
	                         tdtsdy * (stream.offset(cv_b, 1) - cv_b);

	    DFEVar unew_b = itertick.eq(n - 1) ? stream.offset(unew, (n * (m - 2)) + 1) :
	    	            j.eq(n - 1) ? stream.offset(unew, -n + 1) :
	    	            i.eq(0) ? stream.offset(unew, n * (m - 1)) :
	    	            unew;

	    DFEVar vnew_b = itertick.eq(0) ? stream.offset(vnew, n - 1) :
		    	        j.eq(0) ? stream.offset(vnew, n - 1) :
		    	        i.eq(m -1) ? stream.offset(vnew, -n * (m - 1)) :
		    	        vnew;

		DFEVar pnew_b = itertick.eq(n * m - 1) ? stream.offset(pnew, (-n * m) + 1) :
	                    j.eq(n - 1) ? stream.offset(pnew, -n + 1) :
    	                i.eq(m - 1) ? stream.offset(pnew, -n * (m - 1)) :
    	                pnew;

    	// alpha only applies after the first iteration
    	DFEVar alphaval = tick >= m * n ? alpha : 0.0;

    	// Carry the values forward for the next loop
    	carriedp <== stream.offset(pnew_b, -plength);
    	carriedu <== stream.offset(unew_b, -plength);
    	carriedv <== stream.offset(vnew_b, -plength);
    	carriedpold <== stream.offset(p + alphaval * (pnew_b - 2.0 * p + pold), -plength);
    	carrieduold <== stream.offset(u + alphaval * (unew_b - 2.0 * u + uold), -plength);
    	carriedvold <== stream.offset(v + alphaval * (vnew_b - 2.0 * v + vold), -plength);

    	// Only send the outputs on the last iteration
        io.output("unew", unew_b, type, iter.eq(itmax - 1));
	    io.output("vnew", vnew_b, type, iter.eq(itmax - 1));
	    io.output("pnew", pnew_b, type, iter.eq(itmax - 1));
	}
}

