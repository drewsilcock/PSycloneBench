package shallow;

import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Count;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Count.Counter;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.CounterChain;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Stream.OffsetExpr;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;

class shallowKernel extends Kernel {

	private static final DFEType type = dfeFloat(11, 53);

	protected shallowKernel(KernelParameters parameters) {
		super(parameters);

		int m = 128, n = 128, itmax = 10;

		OffsetExpr plength = stream.makeOffsetAutoLoop("plength");

		// Carry over variables from the previous loop iteration
		DFEVar carriedp = type.newInstance(this);
		DFEVar carriedu = type.newInstance(this);
		DFEVar carriedv = type.newInstance(this);
		DFEVar carriedpb = type.newInstance(this);
		DFEVar carriedub = type.newInstance(this);
		DFEVar carriedvb = type.newInstance(this);
		DFEVar carriedpold = type.newInstance(this);
		DFEVar carrieduold = type.newInstance(this);
		DFEVar carriedvold = type.newInstance(this);

		CounterChain tickchain = control.count.makeCounterChain();
		CounterChain arraychain = control.count.makeCounterChain();

		DFEVar looplength = plength.getDFEVar(getKernel(), dfeUInt(32));

		// tick is the global tick count since the start of the simulation
		DFEVar tick = tickchain.addCounter(((itmax - 1) * looplength) + (m * n), 1);
		// iter is the current iteration (0 .. itmax - 1)
		DFEVar iter = arraychain.addCounter(itmax, 1);
		// itertick is the tick within the current iteration (0 .. looplength - 1)
		DFEVar itertick = arraychain.addCounter(looplength, 1);

		debug.simPrintf(tick.eq(0), "Loop length: %d\n", looplength);

		// i & j are set up to represent the position within the arrays for the current
		// iteration. They don't count when waiting for the loop carried values
		Count.Params jparams =  control.count.makeParams(32).withMax(n)
		    .withInc(1).withEnable(itertick < m * n);
		Counter jcounter = control.count.makeCounter(jparams);
		DFEVar j = jcounter.getCount();

		Count.Params iparams = control.count.makeParams(32).withMax(m).withInc(1).withEnable(jcounter.getWrap());
		Counter icounter = control.count.makeCounter(iparams);
		DFEVar i = icounter.getCount();

		// We only need to read the inputs from the CPU on the first iteration
		DFEVar pcpu = io.input("p", type, tick < m * n);
		DFEVar ucpu = io.input("u", type, tick < m * n);
		DFEVar vcpu = io.input("v", type, tick < m * n);
		DFEVar pbcpu = io.input("pb", type, tick < 2 * n);
		DFEVar ubcpu = io.input("ub", type, tick < 2 * n);
		DFEVar vbcpu = io.input("vb", type, tick < 2 * n);
		DFEVar poldcpu = io.input("pold", type, tick < m * n);
		DFEVar uoldcpu = io.input("uold", type, tick < m * n);
		DFEVar voldcpu = io.input("vold", type, tick < m * n);
		DFEVar fsdx = io.scalarInput("fsdx", type);
		DFEVar fsdy = io.scalarInput("fsdy", type);
		DFEVar tdt = io.scalarInput("tdt", type);
		DFEVar dx = io.scalarInput("dx", type);
		DFEVar dy = io.scalarInput("dy", type);
		DFEVar alpha = io.scalarInput("alpha", type);

		DFEVar p = iter.eq(0) ? pcpu : carriedp;
		DFEVar u = iter.eq(0) ? ucpu : carriedu;
		DFEVar v = iter.eq(0) ? vcpu : carriedv;
		DFEVar pb = iter.eq(0) ? pbcpu : carriedpb;
		DFEVar ub = iter.eq(0) ? ubcpu : carriedub;
		DFEVar vb = iter.eq(0) ? vbcpu : carriedvb;
		DFEVar pold = iter.eq(0) ? poldcpu : carriedpold;
		DFEVar uold = iter.eq(0) ? uoldcpu : carrieduold;
		DFEVar vold = iter.eq(0) ? voldcpu : carriedvold;

		DFEVar cu_b =
			i.eq(0) ? calc_cu(pb, ub, n, n) :
			calc_cu(p, u, -n, 0);

	 	DFEVar cv_l =
	 		j.eq(0) ? calc_cv(p, v, n - 1) :
	 		calc_cv(p, v, 0);
	 	DFEVar cv_b1 =
	 		i.eq(0) ? calc_cv(pb, vb, n) :
	 		cv_l;

	 	DFEVar cv_b =
	 		j.eq(0) ? calc_cv(p, v, n - 1) :
	 		cv_b1;

	 	DFEVar z = calc_z(v, u, p, fsdx, fsdy, n);
	 	DFEVar z_l =
	 		j.eq(0) ? stream.offset(z, n -1) :
	 		z;
	 	DFEVar z_b = itertick.eq(0) ? (fsdx * (stream.offset(vb, n + n - 1) - stream.offset(vb, n - 1)) - fsdy * ( stream.offset(ub, n + n - 1) - stream.offset(ub, n - 1 + n - 1))) /
	 		(stream.offset(pb, n - 1 + n - 1) + stream.offset(pb, -1 + n - 1) + stream.offset(pb, n - 1) + stream.offset(pb, n + n - 1)) :
	 		i.eq(0) ? (fsdx * (stream.offset(vb, n) - vb) - fsdy * ( stream.offset(ub, n) - stream.offset(ub, n - 1))) /
	 		(stream.offset(pb, n - 1) + stream.offset(pb, -1) + pb + stream.offset(pb, n)) : z_l ;

		DFEVar h =
			p + 0.25 * (stream.offset(u, n) * stream.offset(u, n) + u *
			u + stream.offset(v, 1) * stream.offset(v, 1) + v * v);
		DFEVar h_l =
			j.eq(n - 1) ?  stream.offset(h, -n + 1)  :
			h;
		DFEVar h_b =
			i.eq(m - 1) ? stream.offset(h_l, -n * (m - 1)) :
			h_l;

		// tdt doubles after the first iteration
		DFEVar tdtval = tick >= m * n ? tdt + tdt : tdt;
		DFEVar tdts8 = tdtval / 8.0;
		DFEVar tdtsdx = tdtval / dx;
		DFEVar tdtsdy = tdtval / dy;

		DFEVar unew = uold + tdts8 * (stream.offset(z_b, 1) + z_b) *
			(stream.offset(cv_b, 1) + stream.offset(cv_b, -n + 1) + stream.offset(cv_b, -n) + cv_b) -
			tdtsdx * (h_b - stream.offset(h_b, -n));
		DFEVar unew_l =
			j.eq(n - 1) ? stream.offset(unew, -n + 1) :
			unew;
		DFEVar unew_bl =
			i.eq(0) ? stream.offset(uold,n * (m - 1))  + tdts8 * (stream.offset(z_b, 1) + stream.offset(z_b, 0)) *
			(stream.offset(cv_b, n * (m - 1) + 1) + stream.offset(cv_b, n * (m - 1) -n + 1) + stream.offset(cv_b, n * (m - 1)-n) + stream.offset(cv_b, n * (m - 1))) -
			tdtsdx * (stream.offset(h_b, n * (m - 1)) - stream.offset(h_b, n * (m - 1)-n)) :
			unew_l;
		DFEVar unew_b =
			j.eq(n - 1) ? stream.offset(unew_bl, -n + 1) :
			unew_bl;

		DFEVar vnew = vold - tdts8 * (stream.offset(z_b, n) + z_b) *
			(stream.offset(cu_b, n) + cu_b + stream.offset(cu_b, -1) + stream.offset(cu_b, n -1)) -
			tdtsdy * (h_b - stream.offset(h_b, -1));
		DFEVar vnew_r =
			j.eq(0) ? stream.offset(vnew, n - 1) :
			vnew;
		DFEVar vnew_b =
			i.eq(m -1) ? stream.offset(vnew_r, -n * (m - 1)) :
			vnew_r;

		DFEVar pnew = pold - tdtsdx * (stream.offset(cu_b, n) - cu_b) -
			tdtsdy * (stream.offset(cv_b, 1) - cv_b);
		DFEVar pnew_l =
			j.eq(n - 1) ? stream.offset(pnew, -n + 1) :
			pnew;
		DFEVar pnew_b =
			i.eq(m - 1) ? stream.offset(pnew_l, -n * (m - 1)) :
			pnew_l;

		// alpha only applies after the first iteration
		DFEVar alphaval = tick >= m * n ? alpha : 0.0;

		// Carry the values forward for the next loop
		carriedp <== stream.offset(pnew_b, -plength);
		carriedu <== stream.offset(unew_b, -plength);
		carriedv <== stream.offset(vnew_b, -plength);
		carriedpb <== stream.offset(pnew_b, -(plength - (n * m) + 2 * n));
		carriedub <== stream.offset(unew_b, -(plength - (n * m) + 2 * n));
		carriedvb <== stream.offset(vnew_b, -(plength - (n * m) + 2 * n));
		carriedpold <== stream.offset(p + alphaval * (pnew_b - 2.0 * p + pold), -plength);
		carrieduold <== stream.offset(u + alphaval * (unew_b - 2.0 * u + uold), -plength);
		carriedvold <== stream.offset(v + alphaval * (vnew_b - 2.0 * v + vold), -plength);

		// Only send the outputs on the last iteration
		io.output("unew", unew_b, type, iter.eq(itmax - 1));
		io.output("vnew", vnew_b, type, iter.eq(itmax - 1));
		io.output("pnew", pnew_b, type, iter.eq(itmax - 1));
	}

	DFEVar calc_cu(DFEVar p, DFEVar u, int poffset, int uoffset) {
		return 0.5 * (p + stream.offset(p, poffset)) * stream.offset(u, uoffset);
	}
	DFEVar calc_cv(DFEVar p, DFEVar v, int offset) {
		return 0.5 * (stream.offset(p, offset) + stream.offset(p, offset - 1)) * stream.offset(v, offset);
	}
	DFEVar calc_z(DFEVar v, DFEVar u, DFEVar p, DFEVar fsdx, DFEVar fsdy, int offset) {
		return (fsdx * (v - stream.offset(v, -offset)) - fsdy * (u - stream.offset(u, -1))) /
			(stream.offset(p, -offset - 1) + stream.offset(p, -1) + p + stream.offset(p, -offset));
	}

}

